{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red255\green102\blue0;\red96\green96\blue96;
\red0\green0\blue255;\red0\green0\blue191;\red51\green51\blue191;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs18 \cf2 // Forest project - SC code\cf0 \
\
\cf2 /*\
NOTE: This can receive the following OSC messages (type & ranges in brackets):\
Message: '/forestAmp', rodNo (int 0-149), value (float 0.0-1.0)\
Message: '/forestFreq', rodNo (int 0-149), value (float 0.0-20000.0)\
Message: '/forestPos', rodNo (int 0-149), value (float 0.0-1.0)\
Message: '/forestCentre', rodNo (int 0-149), value (float 0.0-1.0)\
\
e.g message: ['/forestAmp", 15, 0.33] means set the amp of rod 15 to 0.33\
*/\cf0 \
\
\
\cf2 /*\
NOTE\
new synthesis fields to add:\
	amplitudeVariation, // perlin\
	frequencyVariation, \
\
*/\cf0 \
\
\
(\
	\cf2 // initialise\cf0 \
	\cf3 ~rodCount\cf0  = 150;\
	\cf3 ~globalVolumeInit\cf0  = 0.25;\
	\cf3 ~windowTitle\cf0  = \cf4 "Forest - stereo sine waves"\cf0 ;\
	\
	\cf2 // sound functions - add new rows at end to create more sound options (see template row)\cf0 \
	\cf3 ~arrSoundFuncs\cf0  = [\
		[\cf4 "Sine + octave"\cf0 , \{\cf5 arg\cf0  freq, shape; (1 - shape) * \cf6 SinOsc\cf0 .ar(freq, 0) + (shape * \cf6 SinOsc\cf0 .ar(freq * 2, 0));\}],\
		[\cf4 "Sine + wobble"\cf0 , \{\cf5 arg\cf0  freq, shape; \cf6 Mix\cf0 .new(\cf6 SinOsc\cf0 .ar([freq, freq * (1 + (shape * 0.01))], 0));\}],\
		[\cf4 "Dust Ringz + density"\cf0 , \{\cf5 arg\cf0  freq, shape;  \cf6 Ringz\cf0 .ar(\cf6 Dust\cf0 .ar(0.5 + (shape * 7), 0.5), freq, 2) \}],\
		[\cf4 "Sine Ringz + wobble"\cf0 , \{\cf5 arg\cf0  freq, shape;  \cf6 Ringz\cf0 .ar(\cf6 SinOsc\cf0 .ar([freq, freq * (1 + (shape * 0.01))] * 0.6, 0, 0.03), freq, 0.3) \}],\
		[\cf4 "Klank Impulses + speed"\cf0 , \{\cf5 arg\cf0  freq, shape;  \
			\cf6 Klank\cf0 .ar(`[[freq, freq * 3.355, 5.765, freq * 8.615], \cf7 nil\cf0 , [1, 1, 1, 1]], \cf6 Impulse\cf0 .ar((\cf6 LFBrownNoise2\cf0 .kr(0.1) * (1 + (shape * 20))), 0, 0.5)) \}],\
		[\cf4 "Klank noise 1"\cf0 , \{\cf5 arg\cf0  freq, shape;  \cf6 Klank\cf0 .ar(`[[freq, freq * 3.355, 5.765, freq * 8.615], \
			\cf7 nil\cf0 , [1, 1, 1, 1]], \cf6 PinkNoise\cf0 .ar(0.07)) \}],\
		[\cf4 "Klank noise 2"\cf0 , \{\cf5 arg\cf0  freq, shape;  \cf6 Klank\cf0 .ar(`[ (1..13)*freq, 1/(1..13), \cf7 nil\cf0  ], \cf6 PinkNoise\cf0 .ar(0.07)) \}],\
		[\cf4 "Klank noise 3"\cf0 , \{\cf5 arg\cf0  freq, shape;  \cf6 Klank\cf0 .ar(`[ (1,3..13)*freq, 1/(1,3..13), \cf7 nil\cf0  ], \cf6 PinkNoise\cf0 .ar(0.07)) \}],\
		[\cf4 "Klank noise 4"\cf0 , \{\cf5 arg\cf0  freq, shape;  \
			\cf6 Klank\cf0 .ar(`[ freq/440 *[ 445, 2156.52, 1501.12, 2882.94, 946.15, 879.51, 418.82, 1445.69, 1303.3, 1455.97, 406.44, 1223.28 ], \
				\cf7 nil\cf0 , \cf7 nil\cf0  ], \cf6 PinkNoise\cf0 .ar(0.07)) \}],\
		[\cf4 "Klank noise 5"\cf0 , \{\cf5 arg\cf0  freq, shape;  \
			\cf6 Klank\cf0 .ar(`[ freq/440 *[ 886.91, 1297.96, 431.38, 2197.68, 1058.26, 364.2, 1308.45, 1880.13, 1466.36, 685.48, 1212.76, 1426.61 ], \
				\cf7 nil\cf0 , \cf7 nil\cf0  ], \cf6 PinkNoise\cf0 .ar(0.07)) \}],\
		[\cf4 "Klank noise 6"\cf0 , \{\cf5 arg\cf0  freq, shape;  \
			\cf6 Klank\cf0 .ar(`[ freq/440 *[ 234.24, 237.11, 2930.37, 581.05, 3265.09, 3064.39, 3465.8, 508.14, 3761.15, 210.13, 301.71, 2586.58 ], \
				\cf7 nil\cf0 , \cf7 nil\cf0  ], \cf6 PinkNoise\cf0 .ar(0.07)) \}],\
		[\cf4 "Pulse + width"\cf0 , \{\cf5 arg\cf0  freq, shape; \cf6 Pulse\cf0 .ar(freq, 0.01 + (shape * 0.48))\}],\
		[\cf4 "Sine -> Sawtooth + mix"\cf0 , \{\cf5 arg\cf0  freq, shape; (((1-shape) * \cf6 SinOsc\cf0 .ar(freq)) + (shape * \cf6 Saw\cf0 .ar(freq)));\}],\
		[\cf4 "Sine -> Square + mix"\cf0 , \{\cf5 arg\cf0  freq, shape;  (((1-shape) * \cf6 SinOsc\cf0 .ar(freq)) + (shape * \cf6 Pulse\cf0 .ar(freq, 0.5))); \}],\
		[\cf4 "Sawtooth -> Square wave + mix"\cf0 , \{\cf5 arg\cf0  freq, shape; (((1-shape) * \cf6 Saw\cf0 .ar(freq)) + (shape * \cf6 Pulse\cf0 .ar(freq, 0.5))); \}],\
		[\cf4 "FM 1 + depth"\cf0 , \{\cf5 arg\cf0  freq, shape; 1/3 * \cf6 Mix\cf0 .ar(\cf6 PMOsc\cf0 .ar(freq, freq*[2, 1.5], [0.1 + (shape*pi),0.1 + (shape*pi)], 0)); \}],\
		[\cf4 "FM 2 + depth"\cf0 , \{\cf5 arg\cf0  freq, shape; 1/3 * \cf6 Mix\cf0 .ar(\cf6 PMOsc\cf0 .ar(freq, freq*[1.5, 3.5], [0.1 + (shape*pi),0.1 + (shape*pi)], 0)); \}],\
		[\cf4 "FM 3 + depth"\cf0 , \{\cf5 arg\cf0  freq, shape; 1/3 * \cf6 Mix\cf0 .ar(\cf6 PMOsc\cf0 .ar(freq, freq*[1.0001, 1.4999], [0.1 + (shape*pi),0.1 + (shape*pi)], 0)); \}],\
		[\cf4 "FM 4 + depth"\cf0 , \{\cf5 arg\cf0  freq, shape; 1/3 * \cf6 Mix\cf0 .ar(\cf6 PMOsc\cf0 .ar(freq, freq*[1.0001, 1.9999], [0.1 + (shape*pi),0.1 + (shape*pi)], 0)); \}],\
		[\cf4 "FM 5 + depth"\cf0 , \{\cf5 arg\cf0  freq, shape; 1/3 * \cf6 PMOsc\cf0 .ar(freq, freq * 1.5, 0.1 + (shape*pi), \cf6 SinOsc\cf0 .ar(freq * 3.5, 0, 0.1 + (shape*pi))); \}],\
\
		\cf2 // templates for adding new functions:\cf0 \
		\cf2 //	["Pulse + width", \{arg freq, shape; Pulse.ar(freq, 0.01 + (shape * 0.48))\}],\cf0 \
	];\
\
\
	\cf2 // start server\cf0 \
	s.boot;\
	//\cf6 GUI\cf0 .qt; \
	\cf3 ~synthsRunning\cf0  = \cf7 false\cf0 ;\
	\cf3 ~globalVolumeBus\cf0  = \cf6 Bus\cf0 .control(s, 1);\
	\cf3 ~globalSoundShapeBus\cf0  = \cf6 Bus\cf0 .control(s, 2);\
	\
	\cf4 ""\cf0 .postln;\
	(\cf4 "===  Listening to OSC messages on port: "\cf0  ++ \cf6 NetAddr\cf0 .langPort).postln;\
	\cf4 ""\cf0 .postln;\
	\
	\cf2 // for testing\cf0 \
	\cf3 ~loopBackNetAddr\cf0  = \cf6 NetAddr\cf0 (\cf4 "127.0.0.1"\cf0 , \cf6 NetAddr\cf0 .langPort); \cf2 // loopback\cf0 \
	\
	\cf2 // ~freqs = \{(50 + 60.rand).midicps\} ! ~\cf3 rodCount\cf2 ;\cf0 \
	\cf3 ~freqs\cf0  = \{(48 + [0,12,24].choose + [0, 7, 12, 0,4,7,9,10].choose).midicps\} ! \cf3 ~rodCount\cf0 ;\
	\
	\cf3 ~positions\cf0  = \cf3 ~rodCount\cf0 .collect(\{ \cf5 arg\cf0  i; (i / \cf3 ~rodCount\cf0 ); \});\
	\
	\cf3 ~centres\cf0  = \cf3 ~rodCount\cf0 .collect(\{ \cf5 arg\cf0  i; 0; \});\
	\
	\cf3 ~amps\cf0  = \cf3 ~rodCount\cf0 .collect(\{ \cf5 arg\cf0  i; 0; \});\
	\
	\cf3 ~soundSelectionIndex\cf0  = 0;\
	\
	\cf2 // define functions\cf0 \
	\
	\cf3 ~funcCreateSynthDef\cf0  = \{ \
		\cf6 SynthDef\cf0 (\cf8 \\forest\cf0 , \{ \cf5 |outbus = 0, freq = 440, amp = 0.0, pos = 0.5, centre = 0.0|\cf0 \
			\cf5 var\cf0  oscillator, panOut;\
			\cf5 var\cf0  globalVol = \cf3 ~globalVolumeBus\cf0 .kr * 0.1;\
			\cf5 var\cf0  globalShape = \cf3 ~globalSoundShapeBus\cf0 .kr;\
			\cf2 // oscillator =  SinOsc.ar(freq, 0, globalVol);\cf0 \
			oscillator =  \cf3 ~arrSoundFuncs\cf0 [\cf3 ~soundSelectionIndex\cf0 ][1].value(freq, globalShape);\
			panOut = \cf6 PanAz\cf0 .ar(2, oscillator, pos-0.5, amp * globalVol);\
		\'a0 \'a0 \cf6 Out\cf0 .ar(outbus, panOut);\
		\}).add; \'a0 \
	\};\
	\
	\cf3 ~funcStartSystem\cf0  = \{ \
		fork\{\
			\cf3 ~funcCreateSynthDef\cf0 .value;\
			s.sync;\
			\
			\cf4 "Forest Synth Def has been added."\cf0 .postln;\
			\cf4 ""\cf0 .postln;\
			\
			\cf3 ~globalVolumeBus\cf0 .set(\cf3 ~globalVolumeInit\cf0 );\
			\
			\cf3 ~funcBuildSynths\cf0 .value;\
			\cf3 ~funcStartOSC\cf0 .value;\
		\};\
	\};\
	\
	\cf3 ~funcBuildSynths\cf0  = \{ \
		if (\cf3 ~synthsRunning\cf0  == \cf7 false\cf0 ) \{\
			\cf3 ~synthsRunning\cf0  = \cf7 true\cf0 ;\
			\cf3 ~synths\cf0  = \cf3 ~rodCount\cf0 .collect(\{ \cf5 arg\cf0  i;\
				x = \cf6 Synth\cf0 .new(\cf4 "forest"\cf0 );\
				x.set(\cf4 "freq"\cf0 , \cf3 ~freqs\cf0 [i], \cf4 "out"\cf0 , 0, \cf4 "pos"\cf0 , \cf3 ~positions\cf0 [i], \cf4 "amp"\cf0 , \cf3 ~amps\cf0 [i]);\
				x;\
			\});					\
			\cf4 "Synths have been built."\cf0 .postln;\
			\cf4 ""\cf0 .postln;\
		\};\
	\};	\
	\
	\
	\cf3 ~funcStartOSC\cf0  = \{ \
				\cf3 ~ampFunc\cf0  = \{ \cf5 arg\cf0  msg, time;\
			\'a0 \'a0 		\cf2 // "time: % message: %\\n".postf(time, msg);\cf0 \
					n = msg[1]; \cf2 // synth no\cf0 \
					a = msg[2]; \cf2 // amp\cf0 \
					\cf3 ~amps\cf0 [n] = a;\
					\cf3 ~synths\cf0 [n].set (\cf4 "amp"\cf0 , a);\
				\};\
				\cf3 ~oscForestAmp\cf0  = \cf6 OSCFunc\cf0 .new(\cf3 ~ampFunc\cf0 , \cf8 '/forestAmp'\cf0 );\
				\cf3 ~freqFunc\cf0  = \{ \cf5 arg\cf0  msg, time;\
			\'a0 \'a0 		\cf2 // "time: % message: %\\n".postf(time, msg);\cf0 \
					n = msg[1]; \cf2 // synth no\cf0 \
					a = msg[2]; \cf2 // freq\cf0 \
					\cf3 ~freqs\cf0 [n] = a;\
					\cf3 ~synths\cf0 [n].set (\cf4 "freq"\cf0 , a);\
				\};\
				\cf3 ~oscForestFreq\cf0  = \cf6 OSCFunc\cf0 .new(\cf3 ~freqFunc\cf0 , \cf8 '/forestFreq'\cf0 );\
				\cf3 ~posFunc\cf0  = \{ \cf5 arg\cf0  msg, time;\
			\'a0 \'a0 		\cf2 // "time: % message: %\\n".postf(time, msg);\cf0 \
					n = msg[1]; \cf2 // synth no\cf0 \
					a = msg[2]; \cf2 // pos\cf0 \
					\cf3 ~positions\cf0 [n] = a;\
					\cf3 ~synths\cf0 [n].set (\cf4 "pos"\cf0 , a);\
				\};\
				\cf3 ~oscForestPos\cf0  = \cf6 OSCFunc\cf0 .new(\cf3 ~posFunc\cf0 , \cf8 '/forestPos'\cf0 );\
				\cf3 ~centreFunc\cf0  = \{ \cf5 arg\cf0  msg, time;\
			\'a0 \'a0 		\cf2 // "time: % message: %\\n".postf(time, msg);\cf0 \
					n = msg[1]; \cf2 // synth no\cf0 \
					a = msg[2]; \cf2 // centre\cf0 \
					\cf3 ~centres\cf0 [n] = a;\
					\cf3 ~synths\cf0 [n].set (\cf4 "centre"\cf0 , a);\
				\};\
				\cf3 ~oscForestCentre\cf0  = \cf6 OSCFunc\cf0 .new(\cf3 ~centreFunc\cf0 , \cf8 '/forestCentre'\cf0 );\
			\
				\cf4 "Forest system has been built."\cf0 .postln;\
				\cf4 ""\cf0 .postln;\
				\cf4 "=== OSC Message Types (ranges in brackets): "\cf0 .postln;\
				\cf4 "Message: '/forestAmp', rodNo (int 0-149), value (float 0.0-1.0)"\cf0 .postln;\
				\cf4 "Message: '/forestFreq', rodNo (int 0-149), value (float 0.0-20000.0)"\cf0 .postln;\
				\cf4 "Message: '/forestPos', rodNo (int 0-149), value (float 0.0-1.0)"\cf0 .postln;\
				\cf4 "Message: '/forestCentre', rodNo (int 0-149), value (float 0.0-1.0)"\cf0 .postln;\
				\cf4 "(N.B. /forestCentre has no effect on Stereo Panning version of Forest)"\cf0 .postln;\
				\cf4 ""\cf0 .postln;\
	\};	\
	\
	\cf3 ~funcQuit\cf0  = \{ \
		\cf3 ~funcKillSynths\cf0 .value;\
		\cf3 ~funcKillOsc\cf0 .value;\
		s.quit;\
	\};	\
	\
	\cf3 ~funcKillSynths\cf0  = \{ \
		if (\cf3 ~synthsRunning\cf0  == \cf7 true\cf0 ) \{\
			\cf3 ~rodCount\cf0 .do(\{\cf5 arg\cf0  item, i;\
				\cf3 ~synths\cf0 [i].free;\
			\});\
			\cf3 ~synthsRunning\cf0  = \cf7 false\cf0 ;			\
			\cf4 "All synths have been killed."\cf0 .postln;\
			\cf4 ""\cf0 .postln;\
		\};\
	\};	\
	\cf3 ~funcKillOsc\cf0  = \{ \
			\cf3 ~oscForestAmp\cf0 .remove(\cf3 ~ampFunc\cf0 );\
			\cf3 ~oscForestFreq\cf0 .remove(\cf3 ~freqFunc\cf0 );\
			\cf3 ~oscForestPos\cf0 .remove(\cf3 ~posFunc\cf0 );\
			\cf3 ~oscForestCentre\cf0 .remove(\cf3 ~centreFunc\cf0 );\
	\};	\
	\
\
	\cf3 ~funcRebuildSynths\cf0  = \{ \
		fork \{\
			\cf3 ~funcKillSynths\cf0 .value;\
			\cf3 ~funcCreateSynthDef\cf0 .value;\
			s.sync;\
			\cf3 ~funcBuildSynths\cf0 .value;\
		\};\
	\};	\
	\
	\
	\
	\cf3 ~funcRandomiseAmps\cf0  = \{ \
		\cf3 ~rodCount\cf0 .do(\{\cf5 arg\cf0  item, i;\
			q = 1.0.rand;\
			if (q < 0.8) \{r = 0;\} \{r = 0.99.rand;\};\
			\cf3 ~loopBackNetAddr\cf0 .sendMsg(\cf4 "/forestAmp"\cf0 , i, r);\
		\});\
		\
		\cf4 "All amplitudes have been randomised."\cf0 .postln;\
		\cf4 ""\cf0 .postln;\
	\};\
	\
	\cf3 ~funcZeroAmps\cf0  = \{ \
		\cf3 ~rodCount\cf0 .do(\{\cf5 arg\cf0  item, i;\
			\cf3 ~loopBackNetAddr\cf0 .sendMsg(\cf4 "/forestAmp"\cf0 , i, 0);\
		\});\
		\
		d.value_(0);\
		\cf4 "All amplitudes have been set to zero."\cf0 .postln;\
		\cf4 ""\cf0 .postln;\
	\};\
	\
	\
	\cf2 ////////////////////////////////////////////////////////////\cf0 \
	\
	\cf2 // ~funcStartSystem.value;\cf0 \
\
	\cf2 // GUI SETUP	\cf0 \
	\
	w = \cf6 Window\cf0 .new(\cf3 ~windowTitle\cf0 , \cf6 Rect\cf0 ( 300, 300, 400, 500));\
	w.onClose_(\{ \
		\
		"User has Quit".postln;\
		\cf3 ~funcQuit\cf0 .value;\
	\});\
	w.view.decorator = \cf6 FlowLayout\cf0 ( w.view.bounds, 10@10, 20@5 );\
\
	\cf2 // clear post window\cf0 \
	\cf6 Document\cf0 .listener.string = \cf4 " "\cf0 ;\
	\
	a = \cf6 Button\cf0 (w, \cf6 Rect\cf0 (0, 0, 380, 30))\
\'a0 \'a0 \'a0 \'a0 .states_([\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 [\cf4 "Start system"\cf0 , \cf6 Color\cf0 .black, \cf6 Color\cf0 .green],\
\'a0 \'a0 \'a0 \'a0 ])\
\'a0 \'a0 \'a0 \'a0 .action_(\{ \
			\cf3 ~funcStartSystem\cf0 .value;\
		\});\
\
	b = \cf6 Button\cf0 (w, \cf6 Rect\cf0 (0, 0, 380, 30))\
\'a0 \'a0 \'a0 \'a0 .states_([\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 [\cf4 "Randomize all amplitudes"\cf0 , \cf6 Color\cf0 .black, \cf6 Color\cf0 .blue],\
\'a0 \'a0 \'a0 \'a0 ])\
\'a0 \'a0 \'a0 \'a0 .action_(\{ \
			\cf3 ~funcRandomiseAmps\cf0 .value;\
		\});\
\
	c = \cf6 Button\cf0 (w, \cf6 Rect\cf0 (0, 0, 380, 30))\
\'a0 \'a0 \'a0 \'a0 .states_([\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 [\cf4 "Zero all amplitudes"\cf0 , \cf6 Color\cf0 .black, \cf6 Color\cf0 .grey],\
\'a0 \'a0 \'a0 \'a0 ])\
\'a0 \'a0 \'a0 \'a0 .action_(\{ \
			\cf3 ~funcZeroAmps\cf0 .value;\
		\});\
\
	w.front;\
	\
	m = \cf6 PopUpMenu\cf0 (w,\cf6 Rect\cf0 (10, 10, 380, 30));\
	m.items = \cf3 ~arrSoundFuncs\cf0 .collect(\{\cf5 arg\cf0  item, i; item[0];\});\
	m.background_(\cf6 Color\cf0 .white);\
	m.action = (\{ \cf5 arg\cf0  view;\
		\cf3 ~soundSelectionIndex\cf0  = view.value;\
		\cf3 ~funcRebuildSynths\cf0 .value;\
	\});\
\
	j = \cf6 EZSlider\cf0 ( w, \'a0 \'a0 \'a0 \'a0 \cf2 // parent\cf0 \
		\cf6 Rect\cf0 (0, 0, 380, 20), \cf2 // bounds\cf0 \
\'a0 \'a0 \'a0 	\cf4 "Variation"\cf0 , \cf2 // label\cf0 \
\'a0 \'a0 		\cf8 \\unipolar\cf0 , \cf2 // ControlSpec\cf0 \
	\'a0 \'a0 \'a0\{ \cf5 arg\cf0  ez;\
			\cf3 ~globalSoundShapeBus\cf0 .value = ez.value;\
		\});\
	j.value = 0;\
\
	\
	g = \cf6 EZSlider\cf0 ( w, \'a0 \'a0 \'a0 \'a0 \cf2 // parent\cf0 \
		\cf6 Rect\cf0 (0, 0, 380, 20), \cf2 // bounds\cf0 \
\'a0 \'a0 \'a0 	\cf4 "Volume"\cf0 , \cf2 // label\cf0 \
\'a0 \'a0 		\cf8 \\amp\cf0 , \cf2 // controlSpec\cf0 \
	\'a0 \'a0 \'a0\{ \cf5 arg\cf0  ez;\
			\cf3 ~globalVolumeBus\cf0 .value = ez.value;\
		\});\
	g.value = \cf3 ~globalVolumeInit\cf0 ;\
	\
	l = \cf6 StaticText\cf0 (w, \cf6 Rect\cf0 (0, 0, 380, 20));\
	l = \cf6 StaticText\cf0 (w, \cf6 Rect\cf0 (0, 0, 380, 20));\
	l.string = \cf4 "For testing Rod 0 controls:"\cf0 ;\
\
	\
	d = \cf6 EZSlider\cf0 ( w, \'a0 \'a0 \'a0 \'a0 \cf2 // parent\cf0 \
		\cf6 Rect\cf0 (0, 0, 380, 20), \cf2 // bounds\cf0 \
\'a0 \'a0 \'a0 	\cf4 "Amp 0"\cf0 , \cf2 // label\cf0 \
\'a0 \'a0 		\cf8 \\amp\cf0 , \cf2 // controlSpec\cf0 \
	\'a0 \'a0 \'a0\{ \cf5 arg\cf0  ez;\
			\cf3 ~loopBackNetAddr\cf0 .sendMsg(\cf4 "/forestAmp"\cf0 , 0, ez.value);\
		\});\
	e = \cf6 EZSlider\cf0 ( w, \'a0 \'a0 \'a0 \'a0 \cf2 // parent\cf0 \
		\cf6 Rect\cf0 (0, 0, 380, 20), \cf2 // bounds\cf0 \
\'a0 \'a0 \'a0 	\cf4 " Freq 0"\cf0 , \cf2 // label\cf0 \
\'a0 \'a0 		\cf6 ControlSpec\cf0 (48.midicps, 96.midicps, \cf8 \\exp\cf0 , 0, 440, units: \cf4 " Hz"\cf0 ), \cf2 // controlSpec\cf0 \
	\'a0 \'a0 \'a0\{ \cf5 arg\cf0  ez;\
			\cf3 ~loopBackNetAddr\cf0 .sendMsg(\cf4 "/forestFreq"\cf0 , 0, ez.value);\
		\});\
	f = \cf6 EZSlider\cf0 ( w, \'a0 \'a0 \'a0 \'a0 \cf2 // parent\cf0 \
		\cf6 Rect\cf0 (0, 0, 380, 20), \cf2 // bounds\cf0 \
\'a0 \'a0 \'a0 	\cf4 "Pos 0"\cf0 , \cf2 // label\cf0 \
\'a0 \'a0 		\cf6 ControlSpec\cf0 (0, 1, \cf8 \\lin\cf0 , 0, 0.5), \cf2 // controlSpec\cf0 \
	\'a0 \'a0 \'a0\{ \cf5 arg\cf0  ez;\
			\cf3 ~loopBackNetAddr\cf0 .sendMsg(\cf4 "/forestPos"\cf0 , 0, ez.value);\
		\});\
\
	h = \cf6 EZSlider\cf0 ( w, \'a0 \'a0 \'a0 \'a0 \cf2 // parent\cf0 \
		\cf6 Rect\cf0 (0, 0, 380, 20), \cf2 // bounds\cf0 \
\'a0 \'a0 \'a0 	\cf4 "Centre 0"\cf0 , \cf2 // label\cf0 \
\'a0 \'a0 		\cf6 ControlSpec\cf0 (0, 1, \cf8 \\lin\cf0 , 0, 0.0), \cf2 // controlSpec\cf0 \
	\'a0 \'a0 \'a0\{ \cf5 arg\cf0  ez;\
			\cf3 ~loopBackNetAddr\cf0 .sendMsg(\cf4 "/forestCentre"\cf0 , 0, ez.value);\
		\});\
\
	l = \cf6 StaticText\cf0 (w, \cf6 Rect\cf0 (0, 0, 380, 20));\
\
	c = \cf6 Button\cf0 (w, \cf6 Rect\cf0 (0, 0, 380, 30))\
\'a0 \'a0 \'a0 \'a0 .states_([\
\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 [\cf4 "Quit"\cf0 , \cf6 Color\cf0 .black, \cf6 Color\cf0 .red],\
\'a0 \'a0 \'a0 \'a0 ])\
\'a0 \'a0 \'a0 \'a0 .action_(\{ \
			w.close;\
		\});\
		\
	w.front;\
)\
\
\cf2 /* PANNING NOTES\
\
SplayAz spreads an array of channels across a ring of channels. Optional spread and center controls, and levelComp(ensation) (equal power). \
\
*ar (numChans: 4, inArray, spread: 1, level: 1, width: 2, center: 0, orientation: 0.5,levelComp: true)\
\
\
numChans - Number of output channels.\
\
orientation - Should be zero if the front is a vertex of the polygon. The first speaker will be directly in front. Should be 0.5 if the front bisects a side of the polygon. Then the first speaker will be the one left of center.\
\
\
*/\cf0 \
\
\
\
}